<!doctype html>
<html lang="en" prefix="og: http://ogp.me/ns#" xmlns:og="http://opengraphprotocol.org/schema/">
<head>
  <meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
  <link href="/favicon.png" rel="icon" sizes="32x32">
  <link href="//cloud.webtype.com/css/34a9dbc8-2766-4967-a61f-35675306f239.css" rel="stylesheet" type="text/css" />
  <link href="https://fonts.googleapis.com/css?family=Fira+Mono|Fira+Sans:200,400,400i" rel="stylesheet">
  <link href='/talk.css' rel='stylesheet' type='text/css' />

  <title>ФП в браузере-2</title>

  <meta name="author" content="Nikita Prokopov" />
  
  <meta property="og:title" content="ФП в браузере-2" />
  <meta property="og:url" content="https://tonsky.me/talks/2015-frontendconf/" />
  <meta property="og:type" content="article" />

  <meta property="article:published_time" content='' />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="ФП в браузере-2" />

  <meta property="og:description" content="Какие проблемы решает функциональное программирование для фронт-энда. Что в ФП хорошо ложится на специфику браузера, а что не очень. Обзор обстановки: кто, где и что использует. Истории успеха и провалы. Как может выглядеть архитектура современного фронт-энд приложения, использующего ФП" />
  <meta name="twitter:description" content="Какие проблемы решает функциональное программирование для фронт-энда. Что в ФП хорошо ложится на специфику браузера, а что не очень. Обзор обстановки: кто, где и что использует. Истории успеха и провалы. Как может выглядеть архитектура современного фронт-энд приложения, использующего ФП" />

  <meta property="og:site_name" content="tonsky.me" />
  <meta property="article:author" content="https://www.facebook.com/nikitonsky" />
  <meta property="profile:first_name" content="Nikita" />
  <meta property="profile:last_name" content="Prokopov" />
  <meta property="profile:username" content="tonsky" />
  <meta property="profile:gender" content="male" />

  <meta name="twitter:creator" content="@nikitonsky" />

</head>
<body>

<ul class=menu>
  <li><a class="menu__item" href="/">Blog</a>
  <li><a class="menu__item menu__item_inside" href="/talks/">Talks</a>
  <li><a class="menu__item" href="/projects/">Projects</a>
  <li><a class="menu__item" href="/patrons/">Patrons</a>
</ul>

<div class=page>
<p><img class="slide" src="0000 title.png" /></p>

<p>В посте мы поговорим о том, как приемы функционального программирования могут облегчить страдания программиста, пишущего пользовательские интерфейсы.</p>

<p><img class="slide" src="0005 platforms.png" /></p>

<p>Разница в написании интерфейсов под разные платформы небольшая и скорее количественная, чем качественная. Проблемы общие, подходы общие, без экстремумов и даже серьезных флуктуаций. Поэтому пусть вас не смущает обещание «браузера» в названии: речь пойдет об архитектуре, применимой для любых интерфейсов.</p>

<p><img class="slide" src="0010 eshop.png" /></p>

<p>Мы хотим научиться делать сложные интерфейсы: такие, где на экране одновременно присутствуют более одного потока действий. Традиционный подход — потратить много сил и устать — работает, но хочется лучше.</p>

<p>Подход ООП, или более общий «разделяй на компоненты и властвуй», в жизни работает только на банальностях. Компоненты, попав в сложный контекст, начинают зависеть не только от своего состояния, но и от других, выходящих за границы локальной модели, факторов: истории взаимодействия, окружающей обстановки.</p>

<p><img class="slide" src="0015 context.png" /></p>

<p>Чем сильнее мы хотим придать интерфейсу настоящей человеческой адекватности, тем активнее и запутаннее начинают протягиваться связи всех со всеми. Сложность копится в самом управлении информацией, в огромном массиве нюансов поведения и влияний.</p>

<p><img class="slide" src="0020 eshop-deps.png" /></p>

<p>Прямо сейчас мы проблему, конечно, не решим, но витаминки больному прописать попробуем. А именно, обратимся к мудрости предков — функциональному программированию.</p>

<p><img class="slide" src="0040 functional-programming.png" /></p>

<p>Сам по себе термин «ФП», как и любой ультрамодный тренд, намеренно расплывчат, чтобы легче было ловить неадекватов на форумах. Приемы, впрочем, вполне конкретные и дельные.</p>

<p><img class="slide" src="0050 pure-functions.png" /></p>

<p>Чистыми (pure) называются функции, не производящие побочных эффектов: печати, изменения состояния, сетевых запросов. Как правило, чистота фиксируется на уровне соглашений, но бывает и Хаскель. Такие функции безопасно вызывать как угодно, откуда угодно и сколько угодно раз.</p>

<p>Смежным является понятие ссылочной прозрачности (referential transparency) — это функции, не зависящие от глобального состояния, только от собственных аргументов. Результат таких функций можно безопасно кэшировать.</p>

<p>Чистые ссылочно прозрачные функции упрощают чтение кода (наглядно, откуда что пришло и куда ушло) и юнит-тестирование (не нужна установка окружения).</p>

<p>Функциональщики заметили, что бóльшая часть прикладного кода может быть выражена чистыми, ссылочно прозрачными функциями. Императивное программирование остается удобным на уровне библиотечных алгоритмов, грязные функции выносятся за границы ядра и максимально локализуются — так проще следить за эффектами.</p>

<p><img class="slide" src="0055 code-vs-data.png" /></p>

<p>ООП приучило нас хранить данные и код вместе, и мало кто задался вопросом: «не грешновато ли?». На самом деле программы всегда в первую очередь про данные: они берут что-то одно (семь) и превращают это в что-то другое (сорок два).</p>

<p>Иметь данные максимально открытыми, доступными, универсальными удобно — к ним можно применять много разных вещей, не только то, что предусмотрел автор программы. Программа может быть даже не всегда запущена, но данные от этого никуда не деваются.</p>

<p><img class="slide" src="0060 immutability.png" /></p>

<p>Иммутабельность (immutability) знакома многим по строкам: однажды созданную строку нельзя поменять, но можно создать новую, например, конкатенацией. Со старой при этом ничего не происходит, она все так же доступна (исключение — C/C++, но эти ребята любят, чтобы было трудно).</p>

<p>Такой же подход можно распространить на коллекции: списки, словари, множества, структуры. В иммутабельный список нельзя добавить элемент, но можно создать новый список, в котором на один элемент больше.</p>

<p>Естественно, иммутабельные структуры дороже в использовании, но не летально. Хорошие реализации (persistent data structures) переиспользуют части состояния «предыдущих» объектов так, что накладные расходы получаются небольшими:</p>

<p><img class="slide" src="0070 structural-sharing.png" /></p>

<p>Иммутабельность решает в многопоточной среде, но и для однопоточного кода небесполезна. Она сильно упрощает чтение (легко проследить эволюцию объектов, все изменения явны) и бережет от целого класса ошибок «поменял, запутался, забыл».</p>

<p><img class="slide" src="0080 lazyness.png" /></p>

<p>Ленивость (lazyness) это способ отложить вычисления до востребования. Вместо ответа функция может вернуть рецепт вычисления ответа, в надежде, что вызывающая сторона сама им распорядится. Используется в основном для оптимизации вычислений.</p>

<p><img class="slide" src="0090 webapps.png" /></p>

<p>Давайте посмотрим, как применить все вышеперечисленное туда, куда мы изначально хотели: к веб-интерфейсами.</p>

<p>Традиционный веб-интерфейс это одно большое, сложное, глобальное мутабельное дерево DOM:</p>

<p><img class="slide" src="0100 dom.png" /></p>

<p>Пока все думают, что приложение работает, оно меняет это дерево сразу, бесконтрольно и со всех сторон:</p>

<p><img class="slide" src="0105 dom-state.png" /></p>

<p>Примерно такие вещи видят функциональные программисты в своих кошмарах: холодный пот, леденящий ужас, крик посреди ночи, element.appendChild().</p>

<p>Предположим, нам удалось сделать DOM иммутабельным и не глобальным. Допустим, DOM-дерево это просто иммутабельное значение. Тогда наше приложение сводится к чистой функции, переводящей один DOM в другой:</p>

<p><img class="slide" src="0110 doms.png" /></p>

<p>Уже неплохо: такое можно юнит-тестировать. Чтобы проверить, что панелька прячется по клику, мы создаем DOM с панелькой, вызываем нашу функцию и смотрим, что она вернула DOM без панельки. Не нужно поднимать браузер, не нужно прокликивать его до нужного исходного состояния, можно вообще в параллель 48 таких тестов гонять.</p>

<p>Теперь примемся за сложность. Если у нас N состояний DOM-дерева, нам надо написать N² функций, переводящих каждое состояние в каждое. Если нужно добавить новое состояние, нужно написать N функций перехода в него и N функций перехода из него. В реальности паутинка будет пореже, но характер зависимости все равно нелинейный:</p>

<p><img class="slide" src="0120 dom-mess.png" /></p>

<p>В жизни такое редко бывает, а в программировании вот случилось: нас спасает модель. Мы можем свести наше приложение к функции, переводящей модель в DOM:</p>

<p><img class="slide" src="0124 dom-model.png" /></p>

<p>Из разных моделей получается разные деревья:</p>

<p><img class="slide" src="0127 doms-models.png" /></p>

<p>Вся логика реализуется на уровне переходов между моделями. Переходом между DOM-деревьями можно нагрузить библиотеку:</p>

<p><img class="slide" src="0130 model-model-dom-dom.png" /></p>

<p>Это придает какую-никакую структуру и существенно снижает количество кода, работающего с DOM: до N вместо N²:</p>

<p><img class="slide" src="0135 model-model-mess.png" /></p>

<p>Внимательный читатель заметил, что мы свели проблему переходов между домами к проблеме переходов между моделями. Это действительно так, более того, стрелок на картинке стало больше. Сплошное надувательство.</p>

<p>На практике же получается, что модель устроена гораздо проще и логичнее, чем соответствующее ей DOM-представление. В ней гораздо меньше деталей, переходы тривиальнее, краевые случаи не надо обрабатывать специально. То есть, хотя структурно деталек на картинке больше, на практике это ведет к упрощению кода.</p>

<p>До этого момента я рассказывал о широкоизвестных вещах. Примерно так работает React и другие virtual dom фреймворки. Но даже тут уже цветет функциональное программирование: иммутабельный DOM (на самом деле он разовый, то есть выкидывается сразу после генерации, что делает его эффективно иммутабельным), функция рендеринга чистая (React-у нужна свобода решать, где, когда и сколько раз ее звать), глобальное состояние не используется.</p>

<p>И это мы только начали. Давайте пойдем до конца и объявим иммутабельной и модель тоже:</p>

<p><img class="slide" src="0140 immutable-model.png" /></p>

<p>Теперь логика приложения тоже выражается чистой функцией: переход между состояниями берет старую модель и генерирует на ее основании новую.</p>

<p>Иммутабельная модель дает ключ к ленивому рендерингу. Иммутабельные структуры нельзя незаметно поменять глубоко внутри: надо пойти вглубь, поменять там и все обратно аккуратно перепаковать. Поэтому можно очень быстро определить, грязная модель или чистая: достаточно сравнить ссылки.</p>

<p><img class="slide" src="0150 lazy-dom.png" /></p>

<p>Поскольку модель редко меняется целиком, а компоненты приложения зависят от разных частей модели, можно быстро понять, какие куски надо перерисовать, а какие не изменились. Эта оптимизация (shouldComponentUpdate) выключена в React по-умолчанию и включается только вручную под вашу ответственность. Для иммутабельных аргументов ее можно включить сразу везде. Таким образом рендер становится ленивым: вычисляются только те части DOM, которые интересны, все остальное лежит в виде рецептов и не дергается.</p>

<p>Второй приятный бонус иммутабельной модели это хранение истории. Ссылки на старых моделей остаются валидными, и если мы будем хранить их в каком-нибудь списке, можно будет бегать туда-сюда по истории.</p>

<p><img class="slide" src="0153 model-history.png" /></p>

<p>Взглянем на архитектуру целиком:</p>

<p><img class="slide" src="0156 architecture.png" /></p>

<p>Приложение состоит из одной текущей модели, стека истории моделей и функции рендеринга, переводящей модель в DOM. Поскольку рендеру все равно, откуда пришла модель, легко сделать превью предыдущих состояний истории и отмену по Ctrl+Z.</p>

<p>Более того, поскольку рендеру действительно все равно, можно дополнить архитектуру спекулятивной моделью: все превьюшки, незаконченные операции в процессе, неприменённые настройки можно рендерить, просто вычислив, как выглядела бы модель, если бы. Такая модель нигде не сохраняется, вычисляется на лету и просто разово передается рендеру.</p>

<p><img class="slide" src="0158 speculative-model.png" /></p>

<p>На видео видно стек истории (слева внизу) с превью предыдущих состояний и возможностью откатиться. Фигуры, которые еще находятся в процессе рисования, рисуются через спекулятивную модель:</p>

<video class="slide" controls=""><source src="vec history.mp4" type="video/mp4" /></video>

<p>История наших моделей — это голые данные, соответственно, мы можем строить по ним запросы.</p>

<p><img class="slide" src="0160 history-queries.png" /></p>

<p><a href="http://atomic.io/">Atomic.io</a> умеет показывать историю конкретного объекта. По сути, они делают срез истории по конкретному объекту и вклеивают старые версии в текущую модель:</p>

<video class="slide" controls=""><source src="atomic selective history.mp4" type="video/mp4" /></video>

<p>Красота модели отдельно еще и в том, как изящно разбивается архитектура на слабосвязанные части. Рендеринг ничего не знает о синхронизации с сервером, сервер ничего не знает о локальном кешировании, и так далее. Модель можно отправить работать на сервере, если, например, откусить от нее рендер. Каждому из них глубоко все равно, откуда и как появилась модель и кто еще на нее смотрит. Это качество, за которое стоит бороться.</p>

<p><img class="slide" src="0164 decoupling.png" /></p>

<p>Другой пример, когда иммутабельность может быть полезна: совместная работа с документом. В данной архитектуре используется Event Sourcing: модель это результат свертки (fold) всех произошедших с ней событий (тоже, кстати, функциональный концепт):</p>

<p><img class="slide" src="0167 architectures.png" /></p>

<p>Мы храним два лога событий: локальный и подтвержденный сервером.  Все локальные события сначала пишутся в локальный лог. На его основании вычисляется локальная модель и рисуется интерфейс. Это обеспечивает мгновенную обратную связь и работу без интернета.</p>

<p>За кадром, параллельно и независимо, локальный лог пытается синхронизироваться с сервером. Если сервер подтвердил события, локальный лог выкидывается, а подтвержденные события добавляются в подтвержденную часть и применяются к подтвержденной модели. Это обеспечивает идентичность лога на всех клиентах. Уведомление о событиях коллег получается автоматически: сервер просто пушит их сразу в подтвержденный лог.</p>

<p>В этой архитектуре важно иметь возможность хранить предыдущие снэпшоты модели и уметь перевычислять по ним более свежее состояние, ничего при этом не разрушая.</p>

<p>Еще более сумасшедшая штука: отладка с путешествиями во времени:</p>

<p><img class="slide" src="0170 time-travel.png" /></p>

<p>Это тоже своего рода event sourcing, только события здесь записываются на самом раннем, низком уровне — все внешние источники (ввод пользователя, таймеры, сеть) — и только после этого попадают в код приложения.</p>

<p>Такое разделение на (очень сырые) данные и код позволяет сериализовать, переслать и воспроизвести сессию работы с приложением. Что более важно, можно код изменить и посмотреть, как бы выглядела сессия с новым кодом. Пример, <a href="http://debug.elm-lang.org/edit/Stamps.elm">собранный на платформе Elm</a>:</p>

<video class="slide" controls=""><source src="elm debugger.mp4" type="video/mp4" /></video>

<p>Такой подход требует серьезной дисциплины (или технологии, которая ее обеспечит), но и выигрыш почти неслыханный для обычных приложений. Может пригодиться в разработке и техподдержке: получил вместе с багом лог событий, поправил, проверил что баг не повторяется.</p>

<p>Итак, что нужно, чтобы сделать то же самое?</p>

<p><img class="slide" src="0180 ingridients.png" /></p>

<p>Обязательно понадобятся реализации Virtual DOM (react.js, virtual-dom/mercury) и иммутабельных структур данных (mori.js, immutable.js).</p>

<p>Отдельно хочу упомянуть ClojureScript: это зрелый диалект LISP, компилирующийся в JS. Он функциональный, с иммутабельными структурами по-умолчанию, поэтому делать на нем такие вещи одно удовольствие. Большая часть описанных здесь идей так или иначе зародилась именно в его экосистеме, откуда было растащено эпигонами.</p>

<p><img class="slide" src="0190 clojurescript.png" /></p>

<p>Также я упоминал Elm: это пока экспериментальная разработка, в которой гарантируется строгость и чистота, и многие из описанных вещей получаются автоматически.</p>

<p><img class="slide" src="0200 elm.png" /></p>

<p>Несколько проектов, построенных по описанным архитектурам:</p>

<p><img class="slide" src="0210 examples.png" /></p>

<p>Примеры из совершенно разных областей: от обычного сайта с интерфейсом страницы/ссылки (<a href="http://getprismatic.com">Prismatic</a>: ClojureScript, Om), через средней интерактивности интерфейс Continous Integration (<a href="http://circleci.com">CircleCI</a>: ClojureScript, Om) до средства прототипирования (<a href="http://precursorapp.com">Precursor</a>: ClojureScript, Om, DataScript) и веб-графического редактора (<a href="http://atomic.io/">Atomic</a>: JS, React, Immutable.js).</p>

<p>Функциональное программирование уже пришло в мейнстрим и хорошо себя зарекомендовало. Виртуальный DOM и иммутабельные структуры, по-видимому, это то, что ждет нас в ближайшем будущем во всех интерфейсах: от банкомата до чайника. Я рекомендую не ждать, пока W3C согласует спецификацию на виртуальный дом для производителей браузеров, а прыгать на этот поезд уже сейчас.</p>

<p><img class="slide" src="0220 fin.png" /></p>


</div>

<script type="text/javascript">
    var mode = "normal";

    function q(selector) {
      var els = document.querySelectorAll(selector);
      var res = new Array();
      for (var i=0; i<els.length; ++i) {
        res.push(els.item(i));
      }
      return res;
    }

    function q1(selector) {
      return q(selector)[0];
    }

    function windowHeight() {
      return window.innerHeight;
    }

    function windowScroll() {
      return window.scrollY;
    }

    function smooth_scroll(el) {
      var from = windowScroll();
      var to   = (el.offsetTop + el.clientHeight/2) - windowHeight()/2;
          to   = Math.max(0, to);
      var delta = (to-from);
      for(var i=1; i<=19; ++i) {
        var percent = Math.sin(i*1.68/20);
        var pos = from+delta*percent;
        var callback = function(pos) { return function() { window.scrollTo(0, pos); } }(pos);
        setTimeout(callback, i*16);
      }
    }

    function fast_scroll(el) {
      var to = (el.offsetTop + el.clientHeight/2) - windowHeight()/2;
          to = Math.max(0, to);
      window.scrollTo(0, to);
    }

    function currentSlide() {
      var slides = q(".slide");
      for (var i in slides) {
        var slide = slides[i];
        if (slide.offsetTop >= windowScroll() &&
            slide.offsetTop < windowScroll() + 450)
          return slide;
      }
    }

    function nextSlide() {
      var slides = q(".slide");
      for (var i in slides) {
        var slide = slides[i];
        if (slide.offsetTop > windowScroll() + 450) {
          fast_scroll(slide);
          break;
        }
      }
    }


    function prevSlide() {
      var slides = q(".slide");
      for (var i=slides.length-1; i>=0; --i) {
        var slide = slides[i];
        if (slide.offsetTop < windowScroll()) {
          fast_scroll(slide);
          break;
        }
      }
    }

    document.onkeydown = function(e) {
      if (mode == "presentation") {
        // console.log("Pressed", e.keyCode);
        switch(e.keyCode) {
          case 34: // page down
          case 32: // space
          case 39: // right
          case 40: // down
            nextSlide();
            e.preventDefault();
            break;
          case 33: // page up
          case 37: // left
          case 38: // up
            prevSlide();
            e.preventDefault();
            break;
          case 27: // esc
            toggleZoom(currentSlide(), "normal");
            e.preventDefault();
            break;
        }
      }
    }

    
    function toggleZoom(el, where) {
      where = where || (mode == "normal" ? "presentation" : "normal");
      if (where == "presentation") {
        var width =
          window.innerHeight >= window.innerWidth * 9 / 16
            ? window.innerWidth
            : window.innerHeight * 16 / 9;
        var scale  = width / el.clientWidth;
        // var height = scale * el.clientHeight;

        q(".slide").forEach(function(slide){
          slide.style.width = width + "px";
          slide.defaultHeight = slide.clientHeight;
          slide.style.height = slide.clientHeight * scale + "px";
          slide.style.marginLeft = "" + (350 - width/2) + "px";
        });
        mode = "presentation";
      } else {
        q(".slide").forEach(function(slide){
          slide.style.width = "800px";
          slide.style.height = slide.defaultHeight + "px";
          slide.style.marginLeft = "-50px";
        });
        mode = "normal";
      }
      if (el != null)
        fast_scroll(el);
    }

    var slides = document.querySelectorAll("img.slide");
    for (var i=slides.length-1; i>=0; --i) {
      var slide = slides.item(i);
      slide.addEventListener("dblclick", (function(s) { return function(e) { toggleZoom(s); }; })(slide));
    }
</script>